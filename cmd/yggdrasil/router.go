package main

import (
	"fmt"
	"github.com/subzerobo/ratatoskr/cmd/yggdrasil/handlers"
	"github.com/subzerobo/ratatoskr/internal/constants"
	"github.com/subzerobo/ratatoskr/internal/services/authentication"
	"github.com/subzerobo/ratatoskr/pkg/rest"
	"github.com/subzerobo/ratatoskr/pkg/validator"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin/binding"

	"github.com/gin-gonic/gin"

	// docs is generated by Swag CLI, you have to import it.
	_ "github.com/subzerobo/ratatoskr/docs/yggdrasil"

	ginprometheus "github.com/mcuadros/go-gin-prometheus"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func SetupRouter(handler *handlers.YggdrasilHandler, config PrometheusConfig, jwtCfg authentication.JWTConfig) *gin.Engine {
	gin.SetMode(gin.ReleaseMode)
	r := gin.Default()

	// Upgrade gin validator to v10
	binding.Validator = new(validator.DefaultValidator)

	r.MaxMultipartMemory = 8 << 20 // 8 MiB

	r.Use(gin.Recovery())
	r.Use(handler.CORSMiddleware())

	r.NoRoute(func(c *gin.Context) {
		c.JSON(http.StatusNotFound, rest.NotFound)
	})

	// Gin Prometheus
	p := ginprometheus.NewPrometheus("gin")
	p.MetricsPath = fmt.Sprintf("/%s", config.Path)
	if config.UseAuth {
		p.UseWithAuth(r, gin.Accounts{
			config.UserName: config.Password,
		})
	} else {
		p.Use(r)
	}

	// Disable swagger routers in production environment
	r.GET("/docs/*any", ginSwagger.DisablingWrapHandler(swaggerFiles.Handler, "DISABLE_SWAGGER"))

	// Health Check API
	r.GET("/", handler.HealthCheck)

	// V1 Routes
	v1 := r.Group("/v1")
	{
		// Public Routes
		publicV1 := v1.Group("")
		{
			publicV1.POST("/auth/signup", handler.HandleSignup)
			publicV1.POST("/auth/login", handler.HandleLogin)
			publicV1.GET("/auth/oauth/:provider", handler.HandleOAuthLoginURL)
			publicV1.GET("/auth/oauth/callback/:provider", handler.HandleOAuthCallback)
		}

		// Private Routes (Logged-in Users)
		privateV1 := v1.Group("")
		privateV1.Use(handler.JWTMiddleware(jwtCfg.Secret, []string{constants.Pro.String(), constants.Free.String()}))
		{
			// Application Management
			privateV1.POST("/applications", handler.HandleCreateApplication)
			privateV1.GET("/applications", handler.HandleListMyApplication)
			privateV1.GET("/applications/:uuid", handler.HandleApplicationDetail)
			privateV1.PATCH("/applications/:uuid", handler.HandleResetAuthToken)
			privateV1.PUT("/applications/:uuid/:status", handler.HandleUpdateIdentityVerification)

			// Application - Android Groups Management
			privateV1.GET("/application/:app_uuid/android_groups", handler.HandleGetAndroidGroups)
			privateV1.POST("/application/:app_uuid/android_groups", handler.HandleCreateAndroidGroup)
			privateV1.PUT("/application/:app_uuid/android_groups/:uuid", handler.HandleUpdateAndroidGroup)
			privateV1.DELETE("/application/:app_uuid/android_groups/:uuid", handler.HandleDeleteAndroidGroup)

			privateV1.POST("/application/:app_uuid/android_categories/:g_uuid", handler.HandleCreateAndroidCategory)
			privateV1.PUT("/application/:app_uuid/android_categories/:g_uuid/:c_uuid", handler.HandleUpdateAndroidCategory)
			privateV1.DELETE("/application/:app_uuid/android_categories/:g_uuid/:c_uuid", handler.HandleDeleteAndroidCategory)
		}
	}

	var AllowedRoutes map[string]bool = make(map[string]bool, 0)
	routes := r.Routes()
	for _, i := range routes {
		AllowedRoutes[i.Path] = true
	}

	// Remove parameters to avoid increasing of metrics cardinality
	paramStripMap := make(map[string]bool, 0)
	for _, sp := range []string{"app_uuid", "uuid", "id"} {
		paramStripMap[sp] = true
	}

	p.ReqCntURLLabelMappingFn = func(c *gin.Context) string {
		url := c.Request.URL.Path
		for _, p := range c.Params {
			if _, ok := paramStripMap[p.Key]; ok {
				// Found param
				url = strings.Replace(url, p.Value, fmt.Sprintf(":%s", p.Key), 1)
			}
		}
		if _, ok := AllowedRoutes[url]; ok {
			return url
		} else {
			return ""
		}
	}

	return r
}
